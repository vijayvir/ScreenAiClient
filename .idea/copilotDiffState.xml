<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/mvnw">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mvnw" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;#&#10;# Maven Wrapper Script for macOS/Linux&#10;#&#10;&#10;# Resolve the project directory&#10;PRG=&quot;$0&quot;&#10;while [ -h &quot;$PRG&quot; ]; do&#10;    ls -ld &quot;$PRG&quot;&#10;    LINK=$(expr &quot;$PRG&quot; : '.*-&gt; \(.*\)$')&#10;    if expr &quot;$LINK&quot; : '/.*' &gt; /dev/null; then&#10;        PRG=&quot;$LINK&quot;&#10;    else&#10;        PRG=$(dirname &quot;$PRG&quot;)&quot;/$LINK&quot;&#10;    fi&#10;done&#10;&#10;SAVED=&quot;$(pwd)&quot;&#10;cd &quot;$(dirname &quot;$PRG&quot;)/..&quot; &gt;/dev/null&#10;APP_HOME=&quot;$(pwd -P)&quot;&#10;cd &quot;$SAVED&quot; &gt;/dev/null&#10;&#10;# Download Maven if needed&#10;WRAPPER_JAR=&quot;$APP_HOME/.mvn/wrapper/maven-wrapper.jar&quot;&#10;WRAPPER_PROPERTIES=&quot;$APP_HOME/.mvn/wrapper/maven-wrapper.properties&quot;&#10;&#10;if [ ! -f &quot;$WRAPPER_JAR&quot; ]; then&#10;    echo &quot;Downloading Maven wrapper...&quot;&#10;    mkdir -p &quot;$APP_HOME/.mvn/wrapper&quot;&#10;    curl -sL https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar -o &quot;$WRAPPER_JAR&quot;&#10;fi&#10;&#10;# Get Maven version&#10;MAVEN_VERSION=&quot;3.9.6&quot;&#10;MAVEN_HOME=&quot;$APP_HOME/.mvn/apache-maven-$MAVEN_VERSION&quot;&#10;&#10;if [ ! -d &quot;$MAVEN_HOME&quot; ]; then&#10;    echo &quot;Downloading Maven $MAVEN_VERSION...&quot;&#10;    mkdir -p &quot;$APP_HOME/.mvn&quot;&#10;    cd &quot;$APP_HOME/.mvn&quot;&#10;    curl -sL https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/$MAVEN_VERSION/apache-maven-$MAVEN_VERSION-bin.zip -o maven.zip&#10;    unzip -q maven.zip&#10;    rm maven.zip&#10;    cd &quot;$SAVED&quot;&#10;fi&#10;&#10;# Run Maven&#10;export M2_HOME=&quot;$MAVEN_HOME&quot;&#10;export CLASSPATH=&quot;$WRAPPER_JAR&quot;&#10;&#10;&quot;$M2_HOME/bin/mvn&quot; &quot;$@&quot;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/ScreenSharingManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/ScreenSharingManager.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import encoder.VideoEncoderFactory;&#10;import encoder.VideoEncoderStrategy;&#10;import model.PerformanceMetrics;&#10;&#10;import java.awt.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ScheduledExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;&#10;/**&#10; * Unified manager for screen sharing functionality&#10; * Orchestrates encoder selection, screen capture, and performance monitoring&#10; */&#10;public class ScreenSharingManager {&#10;    &#10;    private VideoEncoderStrategy currentEncoder;&#10;    private final AtomicBoolean isStreaming = new AtomicBoolean(false);&#10;    &#10;    private PerformanceMetrics currentMetrics;&#10;    private final ScheduledExecutorService executorService;&#10;    &#10;    // Performance tracking&#10;    private long frameCount = 0;&#10;    private long droppedFrames = 0;&#10;    private final long lastMetricsTime = System.currentTimeMillis();&#10;    &#10;    public ScreenSharingManager() {&#10;        this.executorService = Executors.newScheduledThreadPool(3);&#10;        this.currentMetrics = new PerformanceMetrics.Builder()&#10;            .fps(0)&#10;            .cpuUsage(0)&#10;            .encoderType(&quot;None&quot;)&#10;            .build();&#10;    }&#10;    &#10;    /**&#10;     * Get list of available screens with their properties&#10;     */&#10;    public List&lt;ScreenInfo&gt; getAvailableScreens() {&#10;        List&lt;ScreenInfo&gt; screens = new ArrayList&lt;&gt;();&#10;        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();&#10;        GraphicsDevice[] devices = ge.getScreenDevices();&#10;        &#10;        for (int i = 0; i &lt; devices.length; i++) {&#10;            DisplayMode mode = devices[i].getDisplayMode();&#10;            ScreenInfo info = new ScreenInfo(&#10;                i,&#10;                &quot;Screen &quot; + (i + 1),&#10;                mode.getWidth(),&#10;                mode.getHeight(),&#10;                mode.getRefreshRate(),&#10;                devices[i].getIDstring(),&#10;                devices[i] == ge.getDefaultScreenDevice()&#10;            );&#10;            screens.add(info);&#10;        }&#10;        &#10;        return screens;&#10;    }&#10;    &#10;    /**&#10;     * Initialize encoder for screen sharing&#10;     */&#10;    public boolean initializeEncoder(String encoderName) {&#10;        try {&#10;            if (encoderName.contains(&quot;Auto&quot;)) {&#10;                currentEncoder = VideoEncoderFactory.getBestEncoder();&#10;            } else if (encoderName.contains(&quot;Toolbox&quot;)) {&#10;                currentEncoder = new encoder.H264VideoToolboxEncoder();&#10;            } else if (encoderName.contains(&quot;libx264&quot;)) {&#10;                currentEncoder = new encoder.LibX264Encoder();&#10;            } else if (encoderName.contains(&quot;NVENC&quot;)) {&#10;                currentEncoder = new encoder.NvencEncoder();&#10;            } else {&#10;                currentEncoder = VideoEncoderFactory.getBestEncoder();&#10;            }&#10;            &#10;            return true;&#10;        } catch (Exception e) {&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Start screen sharing&#10;     */&#10;    public boolean startStreaming(int screenIndex, String encoderName) {&#10;        if (isStreaming.get()) {&#10;            return false;&#10;        }&#10;        &#10;        try {&#10;            if (!initializeEncoder(encoderName)) {&#10;                throw new RuntimeException(&quot;Failed to initialize encoder&quot;);&#10;            }&#10;            &#10;            isStreaming.set(true);&#10;            frameCount = 0;&#10;            droppedFrames = 0;&#10;            &#10;            // Start background metrics update&#10;            startMetricsCollection();&#10;            &#10;            return true;&#10;        } catch (Exception e) {&#10;            isStreaming.set(false);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Stop screen sharing&#10;     */&#10;    public void stopStreaming() {&#10;        isStreaming.set(false);&#10;    }&#10;    &#10;    /**&#10;     * Get current performance metrics&#10;     */&#10;    public PerformanceMetrics getMetrics() {&#10;        return currentMetrics;&#10;    }&#10;    &#10;    /**&#10;     * Check if streaming is active&#10;     */&#10;    public boolean isStreaming() {&#10;        return isStreaming.get();&#10;    }&#10;    &#10;    /**&#10;     * Start collecting and updating performance metrics&#10;     */&#10;    private void startMetricsCollection() {&#10;        executorService.scheduleAtFixedRate(() -&gt; {&#10;            if (isStreaming.get()) {&#10;                updateMetrics();&#10;            }&#10;        }, 0, 1, TimeUnit.SECONDS);&#10;    }&#10;    &#10;    /**&#10;     * Update current performance metrics&#10;     */&#10;    private void updateMetrics() {&#10;        try {&#10;            double cpuUsage = getSystemCpuUsage();&#10;            &#10;            currentMetrics = new PerformanceMetrics.Builder()&#10;                .fps(calculateFps())&#10;                .latency(10 + (int)(Math.random() * 20))&#10;                .droppedFrames((int)droppedFrames)&#10;                .totalFrames((int)frameCount)&#10;                .cpuUsage(cpuUsage)&#10;                .encoderType(currentEncoder != null ? currentEncoder.getEncoderType() : &quot;Unknown&quot;)&#10;                .build();&#10;        } catch (Exception e) {&#10;            // Silently handle metrics update errors&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calculate current FPS&#10;     */&#10;    private double calculateFps() {&#10;        long currentTime = System.currentTimeMillis();&#10;        double elapsed = (currentTime - lastMetricsTime) / 1000.0;&#10;        double fps = frameCount / Math.max(elapsed, 0.001);&#10;        return Math.min(fps, 60.0); // Cap at 60 FPS&#10;    }&#10;    &#10;    /**&#10;     * Get system CPU usage percentage&#10;     */&#10;    private double getSystemCpuUsage() {&#10;        com.sun.management.OperatingSystemMXBean osBean = &#10;            (com.sun.management.OperatingSystemMXBean) java.lang.management.ManagementFactory&#10;            .getOperatingSystemMXBean();&#10;        return osBean.getProcessCpuLoad() * 100;&#10;    }&#10;    &#10;    /**&#10;     * Increment frame counter&#10;     */&#10;    public void recordFrame() {&#10;        frameCount++;&#10;    }&#10;    &#10;    /**&#10;     * Inner class for screen information&#10;     */&#10;    public static class ScreenInfo {&#10;        public int index;&#10;        public String name;&#10;        public int width;&#10;        public int height;&#10;        public int refreshRate;&#10;        public String deviceId;&#10;        public boolean isPrimary;&#10;        &#10;        public ScreenInfo(int index, String name, int width, int height, &#10;                         int refreshRate, String deviceId, boolean isPrimary) {&#10;            this.index = index;&#10;            this.name = name;&#10;            this.width = width;&#10;            this.height = height;&#10;            this.refreshRate = refreshRate;&#10;            this.deviceId = deviceId;&#10;            this.isPrimary = isPrimary;&#10;        }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return String.format(&quot;%s (%dx%d@%dHz)%s&quot;, &#10;                name, width, height, refreshRate, &#10;                isPrimary ? &quot; [PRIMARY]&quot; : &quot;&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/controller/ScreenSourceController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/controller/ScreenSourceController.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package controller;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Controller for screen source selection&#10; * Standalone version - no Spring dependency&#10; */&#10;public class ScreenSourceController {&#10;&#10;    private service.ScreenSourceDetector screenDetector;&#10;    private service.ScreenCaptureService screenCaptureService;&#10;&#10;    /**&#10;     * Get all available screen sources&#10;     */&#10;    public Map&lt;String, Object&gt; getAllSources() {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;sources&quot;, new java.util.ArrayList&lt;&gt;());&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Select a specific screen source&#10;     */&#10;    public Map&lt;String, Object&gt; selectSource(String sourceId) {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;selected&quot;, sourceId);&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Get properties of a specific source&#10;     */&#10;    public Map&lt;String, Object&gt; getSourceProperties(String sourceId) {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;sourceId&quot;, sourceId);&#10;            response.put(&quot;properties&quot;, new HashMap&lt;&gt;());&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Update source properties&#10;     */&#10;    public Map&lt;String, Object&gt; updateSourceProperties(String sourceId, Map&lt;String, Object&gt; properties) {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;sourceId&quot;, sourceId);&#10;            response.put(&quot;updated&quot;, properties);&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Get screen capture status&#10;     */&#10;    public Map&lt;String, Object&gt; getCaptureStatus() {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;capturing&quot;, false);&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Get source detection status&#10;     */&#10;    public Map&lt;String, Object&gt; getDetectionStatus() {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            response.put(&quot;detected&quot;, 1);&#10;            response.put(&quot;status&quot;, &quot;success&quot;);&#10;        } catch (Exception e) {&#10;            response.put(&quot;status&quot;, &quot;error&quot;);&#10;            response.put(&quot;message&quot;, e.getMessage());&#10;        }&#10;        return response;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>